package com.yourcompany.aem.models;

import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.models.annotations.Model;
import org.apache.sling.models.annotations.DefaultInjectionStrategy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Locale;
import java.util.Set;

@Model(
    adaptables = SlingHttpServletRequest.class,
    defaultInjectionStrategy = DefaultInjectionStrategy.OPTIONAL
)
public class LocaleModel {

    private static final Logger LOG = LoggerFactory.getLogger(LocaleModel.class);

    @Inject
    private SlingHttpServletRequest request;

    // Initialize ISO language and country codes
    private static final Set<String> ISO_LANGUAGES = new HashSet<>(Arrays.asList(Locale.getISOLanguages()));
    private static final Set<String> ISO_COUNTRIES = new HashSet<>(Arrays.asList(Locale.getISOCountries()));

    /**
     * Retrieves the current locale in either simple or complex form based on the URL structure.
     *
     * @return the locale string (e.g., "en" or "de_CH")
     */
    public String getLocale() {
        String cachedLocale = (String) request.getAttribute("currentLocale");
        if (cachedLocale != null) {
            return cachedLocale;
        }

        // Priority: User Preferred Locale > URL-based Locale > Request Locale > System Default
        String userPreferredLocale = getUserPreferredLocale();
        if (userPreferredLocale != null && !userPreferredLocale.isEmpty()) {
            request.setAttribute("currentLocale", userPreferredLocale);
            return userPreferredLocale;
        }

        Locale locale = determineLocaleFromURL();
        if (locale == null) {
            locale = request.getLocale() != null ? request.getLocale() : Locale.getDefault();
        }

        String localeString = !locale.getCountry().isEmpty()
                ? locale.getLanguage().toLowerCase() + "_" + locale.getCountry().toUpperCase()
                : locale.getLanguage().toLowerCase();

        request.setAttribute("currentLocale", localeString);
        return localeString;
    }

    /**
     * Determines the locale based on the URL path segments.
     *
     * @return the Locale object or null if not determinable from URL
     */
    private Locale determineLocaleFromURL() {
        String[] segments = request.getRequestURI().split("/");

        // Iterate through each segment to find locale patterns
        for (int i = 0; i < segments.length; i++) { // Start at 0 to include first segment
            String segment = segments[i].trim();

            if (segment.isEmpty()) {
                continue; // Skip empty segments
            }

            // Attempt to parse single segment as locale
            Locale singleLocale = parseLocaleSegment(segment);
            if (singleLocale != null) {
                LOG.debug("Locale determined from single segment '{}': {}", segment, singleLocale.toString());
                return singleLocale;
            }

            // Attempt to parse pair of segments as locale (country/language and language/country)
            if (i + 1 < segments.length) {
                String nextSegment = segments[i + 1].trim();
                if (nextSegment.isEmpty()) {
                    continue;
                }

                // Attempt country/language
                Locale pairLocale1 = parseLocaleSegmentPair(segment, nextSegment, true);
                if (pairLocale1 != null) {
                    LOG.debug("Locale determined from segment pair '{}/{}': {}", segment, nextSegment, pairLocale1.toString());
                    return pairLocale1;
                }

                // Attempt language/country
                Locale pairLocale2 = parseLocaleSegmentPair(segment, nextSegment, false);
                if (pairLocale2 != null) {
                    LOG.debug("Locale determined from segment pair '{}/{}': {}", segment, nextSegment, pairLocale2.toString());
                    return pairLocale2;
                }
            }
        }

        return null; // Locale not determined from URL
    }

    /**
     * Parses a single URL segment to extract Locale information.
     *
     * @param segment the URL segment representing locale
     * @return the Locale object or null if the segment doesn't represent a valid locale
     */
    private Locale parseLocaleSegment(String segment) {
        // Normalize segment to handle different separators and cases
        Locale locale = null;

        // Handle different separators and no separators
        if (segment.contains("-")) {
            String[] parts = segment.split("-");
            if (parts.length >= 2) {
                String language = parts[0].toLowerCase();
                String country = parts[1].toUpperCase();
                if (isValidLocale(language, country)) {
                    locale = new Locale(language, country);
                }
            }
        } else if (segment.contains("_")) {
            String[] parts = segment.split("_");
            if (parts.length >= 2) {
                String language = parts[0].toLowerCase();
                String country = parts[1].toUpperCase();
                if (isValidLocale(language, country)) {
                    locale = new Locale(language, country);
                }
            }
        } else if (segment.length() == 4) { // e.g., deCH
            String language = segment.substring(0, 2).toLowerCase();
            String country = segment.substring(2, 4).toUpperCase();
            if (isValidLocale(language, country)) {
                locale = new Locale(language, country);
            }
        } else if (segment.length() == 2) { // e.g., en
            String language = segment.toLowerCase();
            if (ISO_LANGUAGES.contains(language)) {
                locale = new Locale(language);
            }
        }

        return locale;
    }

    /**
     * Parses a pair of URL segments to extract Locale information.
     *
     * @param segment1        the first URL segment
     * @param segment2        the second URL segment
     * @param isCountryFirst  indicates if the first segment is a country code
     * @return the Locale object or null if the segments don't represent a valid locale
     */
    private Locale parseLocaleSegmentPair(String segment1, String segment2, boolean isCountryFirst) {
        String language;
        String country;

        if (isCountryFirst) {
            // First segment is country, second is language
            country = segment1.toUpperCase();
            language = segment2.toLowerCase();
        } else {
            // First segment is language, second is country
            language = segment1.toLowerCase();
            country = segment2.toUpperCase();
        }

        if (isValidLocale(language, country)) {
            return new Locale(language, country);
        }

        return null;
    }

    /**
     * Validates if the language and country codes are valid ISO codes.
     *
     * @param language the language code
     * @param country  the country code
     * @return true if both are valid, false otherwise
     */
    private boolean isValidLocale(String language, String country) {
        return ISO_LANGUAGES.contains(language) && ISO_COUNTRIES.contains(country);
    }

    /**
     * Retrieves the user's preferred locale.
     *
     * @return the user's Locale string or null if not set
     */
    private String getUserPreferredLocale() {
        // Implement logic to retrieve user's preferred locale, e.g., from session or user profile
        // Example placeholder:
        // return session.getAttribute("preferredLocale");
        return null; // Placeholder: No user preference implemented
    }
}